# Block Join Test Plan - Transaction Analysis

## Executive Summary

This document analyzes the **actual transactions** generated by the blockJoin
E2E tests and provides a detailed plan for creating unit tests in
`paragraphBackspace.test.ts` that replicate these exact transaction patterns.

---

## Part 1: Transaction Pattern Analysis

### Test 1: "Paragraph: Enter then Backspace" (Basic Case)

#### Scenario

- Initial document: `"test paragraph"` (1 paragraph, cursor at position 15 -
  end)
- Action 1: Press Enter
- Action 2: Press Backspace
- Expected: Document reverts to original state

#### Transaction 3: Enter Key Press (The Split)

```json
{
  "steps": [
    {
      "stepType": "replace",
      "from": 15,
      "to": 15,
      "slice": {
        "content": [{ "type": "paragraph" }, { "type": "paragraph" }],
        "openStart": 1,
        "openEnd": 1
      }
    },
    {
      "stepType": "replace",
      "from": 15,
      "to": 15,
      "slice": { "content": [{ "type": "text", "text": "​" }] }
    },
    {
      "stepType": "addMark",
      "mark": { "type": "insertion", "attrs": { "id": 1 } },
      "from": 15,
      "to": 16
    },
    {
      "stepType": "replace",
      "from": 18,
      "to": 18,
      "slice": { "content": [{ "type": "text", "text": "​" }] }
    },
    {
      "stepType": "addMark",
      "mark": { "type": "insertion", "attrs": { "id": 1 } },
      "from": 18,
      "to": 19
    }
  ],
  "selection": { "from": 19, "to": 19 },
  "docBefore": "test paragraph",
  "docAfter": "test paragraph​​"
}
```

**Key Observations:**

1. **Step 1**: Split paragraph at position 15
   - Creates 2 paragraphs with `openStart: 1, openEnd: 1`
2. **Step 2**: Insert ZWSP (`\u200B`) at position 15 (end of first block)
3. **Step 3**: Mark ZWSP with insertion mark (ID=1) from 15-16
4. **Step 4**: Insert ZWSP at position 18 (start of second block)
5. **Step 5**: Mark ZWSP with insertion mark (ID=1) from 18-19
6. **Result**: Two ZWSP markers, both marked with same ID

#### Transaction 4: Backspace Key Press (The Join)

```json
{
  "steps": [
    { "stepType": "replace", "from": 18, "to": 19 },
    { "stepType": "replace", "from": 15, "to": 16 },
    { "stepType": "replace", "from": 15, "to": 17, "structure": true }
  ],
  "selection": { "from": 15, "to": 15 },
  "docBefore": "test paragraph​​",
  "docAfter": "test paragraph"
}
```

**Key Observations:**

1. **Step 1**: Delete ZWSP at 18-19 (second block's start)
2. **Step 2**: Delete ZWSP at 15-16 (first block's end)
3. **Step 3**: Join blocks at position 15 (`structure: true`)
4. **Deletion Order**: Second block ZWSP deleted first, then first block ZWSP
5. **Result**: Document reverted, cursor at position 15

---

### Test 2: "Enter at Middle of Text then Backspace"

#### Scenario

- Initial document: `"test paragraph"` (cursor at position 6, after "test ")
- Action 1: Press Enter (splits at middle)
- Action 2: Press Backspace
- Expected: Document rejoins at split point

#### Transaction Pattern (from logs)

**Enter at Position 6:**

```
Steps similar to basic case, but:
- Split occurs at position 6 (not 15)
- ZWSP inserted at position 6 (end of "test ")
- ZWSP inserted at position 8 (start of "paragraph")
- Result: "test ​" | "​paragraph"
```

**Backspace:**

```
- Delete ZWSP at position 8
- Delete ZWSP at position 6
- Join blocks at position 6
- Result: "test paragraph" with cursor at position 6
```

**Critical Difference:**

- Split position affects all subsequent positions
- ZWSP positions: 6 and (6 + 2) = 8 (accounting for paragraph node boundary)

---

### Test 3: "Enter Twice then Backspace Twice" (Nested Suggestions)

#### Scenario

- Initial: `"test paragraph"` (1 paragraph)
- Action 1: Enter → 2 paragraphs
- Action 2: Enter → 3 paragraphs
- Action 3: Backspace → 2 paragraphs
- Action 4: Backspace → 1 paragraph

#### Transaction Pattern

**First Enter (position 15):**

- Creates paragraphs: P1 | P2
- ZWSP at end of P1 (pos 15-16)
- ZWSP at start of P2 (pos 18-19)
- Both marked with ID=1

**Second Enter (position 19, end of P2):**

- Creates paragraphs: P1 | P2 | P3
- ZWSP at end of P2 (pos 19-20)
- ZWSP at start of P3 (pos 22-23)
- Both marked with ID=1 (same ID - this is key!)

**First Backspace (from P3):**

- Deletes ZWSP at 22-23
- Deletes ZWSP at 19-20
- Joins P2 and P3
- Result: P1 | P2, cursor at 19

**Second Backspace (from P2):**

- Deletes ZWSP at 18-19
- Deletes ZWSP at 15-16
- Joins P1 and P2
- Result: P1, cursor at 15

**Critical Observation:**

- All ZWSPs share the same suggestion ID (1)
- Backspace removes pairs in LIFO order (last split reverted first)

---

### Test 4: "Enter then Delete from End of First Block"

#### Scenario

- Initial: `"test paragraph"` at end (pos 15)
- Action 1: Enter
- Action 2: Move cursor to end of first block (pos 15)
- Action 3: Press Delete (forward join)

#### Transaction Pattern (Expected)

**Enter:**

- Same as basic case: split at 15, ZWSPs at 15-16 and 18-19

**Delete from Position 15:**

- User presses Delete while cursor at end of first block
- This should trigger forward join
- Expected steps:
  1. Delete ZWSP at 15-16 (current position)
  2. Delete ZWSP at 18-19 (second block)
  3. Join blocks at 15

**Observed Behavior (from test output):**

```
Final text: test paragraph​
```

- Note the remaining ZWSP! This is the "known limitation" mentioned in the code
- Delete doesn't clean up ZWSPs as cleanly as Backspace

---

### Test 5: "ArrowLeft then Delete"

#### Scenario

- Initial: `"test paragraph"` at end
- Action 1: Enter (creates split)
- Action 2: ArrowLeft (moves cursor from 19 → 18 → 16, end of first block)
- Action 3: Delete

#### Key Insight

This tests that cursor navigation (which generates empty transactions) doesn't
interfere with block join detection.

**Transaction Log Pattern:**

```json
[
  {"steps": [], "selection": {"from": 18, "to": 18}},  // ArrowLeft transaction
  {"steps": [], "selection": {"from": 16, "to": 16}},  // ArrowLeft again (crosses boundary)
  {"steps": [...], ...}  // Delete transaction
]
```

---

## Part 2: Unit Test Implementation Plan

### Test Structure Template

Based on existing `paragraphBackspace.test.ts`, each unit test should follow
this pattern:

```typescript
it("should [description]", () => {
  // 1. Setup: Create document with cursor position tags
  const doc = testBuilders.doc(
    testBuilders.paragraph("test <a>paragraph"),
  ) as TaggedNode;
  const tagA = doc.tag.a;

  // 2. Create the split step
  const splitStep = replaceStep(
    doc,
    tagA,
    tagA,
    new Slice(
      Fragment.from([
        schema.nodes.paragraph.create(null, [schema.text("\u200B")]),
        schema.nodes.paragraph.create(null, [schema.text("\u200B")]),
      ]),
      1,
      1,
    ),
  );

  // 3. Apply as suggestion
  const transaction = editorState.tr;
  suggestReplaceStep(transaction, editorState, doc, splitStep, [], 1);
  const stateAfterSplit = editorState.apply(transaction);

  // 4. Verify ZWSPs added
  const expectedAfterSplit = testBuilders.doc(
    testBuilders.paragraph("test <insertion:1>​</insertion>"),
    testBuilders.paragraph("<insertion:1>​</insertion>paragraph"),
  );
  assert(
    eq(stateAfterSplit.doc, expectedAfterSplit),
    "After split should have ZWSPs",
  );

  // 5. Create backspace step (delete the ZWSP at start of second block)
  const backspaceFrom = tagA + 3; // Position of second ZWSP
  const backspaceTo = tagA + 4;
  const backspaceStep = replaceStep(
    stateAfterSplit.doc,
    backspaceFrom,
    backspaceTo,
  );

  // 6. Apply backspace
  const transaction2 = stateAfterSplit.tr;
  suggestReplaceStep(
    transaction2,
    stateAfterSplit,
    stateAfterSplit.doc,
    backspaceStep,
    [],
    1,
  );
  const finalState = stateAfterSplit.apply(transaction2);

  // 7. Verify document reverted
  const expectedFinal = testBuilders.doc(
    testBuilders.paragraph("test paragraph"),
  );
  assert(eq(finalState.doc, expectedFinal), "Should revert to original");
});
```

---

## Part 3: Specific Tests to Implement

### Priority 1: Critical Missing Tests

#### Test 1: "Enter at End then Backspace" (Basic)

**Purpose:** Test the most basic block join scenario **Transaction Pattern:**
Split at position 15, then backspace from 19 **Key Points:**

- ZWSPs at positions 15-16 and 18-19
- Backspace deletes both and joins
- Verify no ZWSPs remain in final document

**Implementation:**

```typescript
it("should remove suggested paragraph split when backspacing at end of document", () => {
  const doc = testBuilders.doc(
    testBuilders.paragraph("test paragraph<a>"),
  ) as TaggedNode;
  const tagA = doc.tag.a;

  // Split at end (position 15)
  // Apply as suggestion with ID 1
  // Verify ZWSPs at 15-16 and 18-19
  // Backspace from position 19
  // Verify document reverted
});
```

#### Test 2: "Enter at Middle then Backspace"

**Purpose:** Test split not at paragraph boundary **Transaction Pattern:** Split
at position 6 (middle of "test paragraph") **Key Points:**

- Split occurs mid-text: "test " | "paragraph"
- ZWSPs at 6-7 and 9-10
- Backspace should cleanly rejoin

**Implementation:**

```typescript
it("should handle block split in middle of text content", () => {
  const doc = testBuilders.doc(
    testBuilders.paragraph("test <a>paragraph"),
  ) as TaggedNode;
  const tagA = doc.tag.a;

  // Split at position 5 (after "test ")
  // ZWSPs at different positions than end-of-para case
  // Verify correct position calculation
});
```

#### Test 3: "Multiple Cycles"

**Purpose:** Test stability across repeated split/join operations **Transaction
Pattern:** 3 cycles of Enter→Backspace **Key Points:**

- Same suggestion ID used for all splits
- Each cycle should fully revert
- No ZWSP accumulation

**Implementation:**

```typescript
it("should handle multiple sequential split/join cycles", () => {
  let state = editorState;

  for (let i = 0; i < 3; i++) {
    // Cycle i: split then join
    // Verify state === editorState after each cycle
  }
});
```

### Priority 2: Complete Coverage

#### Test 4: "Enter Twice then Backspace Twice"

**Purpose:** Test nested suggestions with same ID **Already Exists?** Check
existing tests - may be similar to "should only join blocks with same suggestion
ID"

#### Test 5: "Delete from End of First Block"

**Purpose:** Test forward join (Delete key, not Backspace) **Key Difference:**
Delete may leave ZWSP markers (known limitation)

#### Test 6: "Block Join with Content"

**Purpose:** Ensure content preservation during join **Scenario:** Split, add
text to second block, then join **Expected:** Text from second block merged into
first

#### Test 7: "ZWSP Cleanup Verification"

**Purpose:** Explicitly check no `\u200B` characters remain **Implementation:**

```typescript
it("should remove all ZWSP markers on successful block join", () => {
  // After join, search doc.textContent for \u200B
  assert(
    !finalState.doc.textContent.includes("\u200B"),
    "No ZWSP should remain",
  );
});
```

#### Test 8: "Different Suggestion IDs"

**Already Exists:** Line 184 of paragraphBackspace.test.ts **Action:** Review
and potentially enhance

#### Test 9: "Block Join at Document Start"

**Purpose:** Edge case - first paragraph **Scenario:** Doc with 2 paragraphs,
split first one, then join

#### Test 10: "Block Join at Document End"

**Purpose:** Edge case - last paragraph **Scenario:** Ensure no off-by-one
errors at document boundaries

---

## Part 4: Position Calculation Reference

### Understanding Position Offsets

In ProseMirror:

- Text positions are **between characters**
- Node boundaries add positions

**Example:** `"test paragraph"`

```
Position:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
Character: t  e  s  t     p  a  r  a  g  r  a  p  h  |
           ^                                            ^
         start                                         end
```

**After split at position 15:**

```
Doc
├─ Paragraph (position 0)
│  ├─ "test paragraph" (0-14)
│  └─ ZWSP at 15-16
├─ [boundary: +1]
└─ Paragraph (position 17)
   ├─ ZWSP at 18-19
   └─ (empty)

Positions:
- First ZWSP: 15-16
- Paragraph boundary: 16-17
- Second ZWSP: 18-19
```

**Formula:**

- If split at position N:
  - First ZWSP: N to N+1
  - Second ZWSP: N+3 to N+4 (accounting for ZWSP + paragraph boundary)

**After split at position 6 (middle):**

```
Doc
├─ Paragraph (position 0)
│  ├─ "test " (0-5)
│  └─ ZWSP at 6-7
├─ [boundary: +1]
└─ Paragraph (position 8)
   ├─ ZWSP at 9-10
   └─ "paragraph" (10-19)

Positions:
- First ZWSP: 6-7
- Paragraph boundary: 7-8
- Second ZWSP: 9-10
```

---

## Part 5: Implementation Notes

### Slice Construction for Splits

**Standard paragraph split slice:**

```typescript
new Slice(
  Fragment.from([
    schema.nodes.paragraph.create(null, [schema.text("\u200B")]),
    schema.nodes.paragraph.create(null, [schema.text("\u200B")]),
  ]),
  1, // openStart: content starts inside first paragraph
  1, // openEnd: content ends inside second paragraph
);
```

### Suggestion ID Consistency

- All tests use suggestion ID = 1 (matching Playwright tests)
- generateId function in E2E tests always returns 1
- Unit tests should also use ID 1 for consistency

### Expected Document Notation

Using `testBuilders`:

```typescript
// Document with insertion-marked ZWSP
testBuilders.paragraph("text<insertion:1>​</insertion>");

// Multiple paragraphs
testBuilders.doc(
  testBuilders.paragraph("first"),
  testBuilders.paragraph("second"),
);
```

### Assertion Pattern

```typescript
assert(eq(actualState.doc, expectedDoc), "Descriptive error message");
```

---

## Part 6: Test Execution Strategy

### Order of Implementation

1. **Start with Test 1** (Enter at end): Simplest case, validates basic pattern
2. **Test 2** (Enter at middle): Adds position calculation complexity
3. **Test 3** (Multiple cycles): Tests stability
4. **Tests 4-6**: Core scenarios
5. **Tests 7-10**: Edge cases and validation

### Validation Checklist per Test

- [ ] Document structure correct after split
- [ ] ZWSP markers present at correct positions
- [ ] ZWSP markers have correct suggestion ID
- [ ] Backspace/Delete triggers block join
- [ ] Both ZWSPs removed
- [ ] Block join occurs at correct position
- [ ] Final document matches original (where applicable)
- [ ] Cursor position correct

---

## Part 7: Expected Challenges

### Challenge 1: Position Mapping

**Issue:** After inserting ZWSPs, all subsequent positions shift **Solution:**
Always calculate positions relative to original tags, then account for:

- ZWSP insertions (+1 each)
- Paragraph boundaries (+1 each)

### Challenge 2: Slice Open Start/End

**Issue:** `openStart` and `openEnd` values affect how content is inserted
**Solution:** For paragraph splits, always use `openStart: 1, openEnd: 1`

### Challenge 3: Different Suggestion IDs

**Issue:** Test with mismatched IDs should NOT join blocks **Solution:** Already
implemented (line 184), review and ensure it uses realistic split pattern

### Challenge 4: Delete vs Backspace

**Issue:** Delete may not clean up ZWSPs (known limitation) **Solution:**
Document this in test, use looser assertions for Delete tests

---

## Part 8: README Content Plan

Based on this analysis, the README should include:

### Sections

1. **Overview**
   - Purpose: Enable proper block join reversion
   - Why: User expectations for suggestion removal

2. **ZWSP Marker System**
   - What they are (`\u200B`)
   - Where they're placed (block boundaries)
   - Why they're needed (mark anchoring)
   - Visual example from transaction logs

3. **Detection Algorithm**
   - 3-phase process (collect, detect pairs, handle joins)
   - Forward vs backward detection
   - Code snippets from actual implementation

4. **Transaction Examples**
   - Show actual transaction JSON from this document
   - Annotate each step
   - Highlight key positions

5. **Position Calculation**
   - Formula for ZWSP positions
   - Diagram showing position offsets

6. **Integration**
   - How it plugs into replaceStep.ts
   - When it activates vs normal flow

7. **Testing**
   - Links to unit and E2E tests
   - How to run tests
   - How to debug with transaction logs

8. **Known Limitations**
   - Delete key ZWSP cleanup
   - Supported block types

---

## Conclusion

This plan provides:

- **Exact transaction patterns** from real E2E tests
- **Detailed implementation guide** for 10 unit tests
- **Position calculation formulas** for accurate test writing
- **Validation checklist** to ensure test quality
- **README outline** based on actual code behavior

**Next Steps:**

1. Implement Priority 1 tests (3 tests)
2. Validate against E2E behavior
3. Implement Priority 2 tests (7 tests)
4. Write README with transaction examples
5. Cross-reference with code comments
